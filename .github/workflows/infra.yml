name: CI (Terraform plan/apply) and Deploy Java #1

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

permissions:
  contents: read

env:
  TF_DIR: tf    

jobs:
  terraform-plan:
    name: Terraform - Plan
    runs-on: ubuntu-latest
    env:
      SSH_PUB_KEY: ${{ secrets.SSH_PUB_KEY || '' }}
    defaults:
      run:
        working-directory: ${{ env.TF_DIR }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-1

      - name: Terraform Init
        run: terraform init -input=false

      - name: Check terraform fmt
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: terraform validate

      - name: Prepare optional ssh.auto.tfvars (from secret) if provided
        if: env.SSH_PUB_KEY != ''
        run: |
          # remove any previous file to avoid leftover incorrect content
          rm -f ssh.auto.tfvars
          # create a proper tfvars file (use double quotes for Terraform)
          cat > ssh.auto.tfvars <<'EOF'
          ssh_public_key = "${{ secrets.SSH_PUB_KEY }}"
          EOF
          echo "Created ssh.auto.tfvars (length: $(wc -c < ssh.auto.tfvars) bytes)"

      - name: "Debug: list TF dir files"
        run: |
          ls -la

      - name: Terraform Plan (create plan.tfplan)
        id: plan
        run: |
          set -euo pipefail
          # run terraform plan, output plan.tfplan in current directory
          terraform plan -input=false -no-color -out=plan.tfplan || true

          if [ -f plan.tfplan ]; then
            terraform show -no-color plan.tfplan > plan.txt || true
            head -n 200 plan.txt > plan_summary.txt || true
          else
            echo "No plan.tfplan produced (plan may have failed)."
            echo "" > plan_summary.txt
          fi

      - name: "Debug: list TF dir files"
        run: |
          ls -la

      - name: Debug before upload - show absolute paths
        run: |
          echo "Workspace: $GITHUB_WORKSPACE"
          echo "TF_DIR: ${{ env.TF_DIR }}"
          ls -la "${{ env.TF_DIR }}" || true
          stat -c '%n %s' "${{ env.TF_DIR }}/plan.tfplan" || true


      - name: Upload plan artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: |
            ${{ env.TF_DIR }}/plan.tfplan
            ${{ env.TF_DIR }}/plan_summary.txt

  terraform-apply:
    name: Terraform - Apply
    runs-on: ubuntu-latest
    env:
      SSH_PUB_KEY: ${{ secrets.SSH_PUB_KEY || '' }}
    needs: terraform-plan
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    defaults:
      run:
        working-directory: ${{ env.TF_DIR }}
    outputs:
      hosts: ${{ steps.set-hosts.outputs.hosts }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-1

      - name: Terraform Init
        run: terraform init -input=false

      - name: Download plan artifact (if exists)
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: ${{ env.TF_DIR }}

      - name: Prepare plan file (use downloaded artifact if present)
        id: prepare-plan
        run: |
          set -euo pipefail
          # if download-artifact created terraform-plan/plan.tfplan put it in working dir
          if [ -f plan.tfplan ]; then
            echo "plan.tfplan already present in TF_DIR"
          elif [ -f terraform-plan/plan.tfplan ]; then
            mv terraform-plan/plan.tfplan ./plan.tfplan
          elif [ -f ../terraform-plan/plan.tfplan ]; then
            mv ../terraform-plan/plan.tfplan ./plan.tfplan
          else
            echo "No plan.tfplan found from artifact. Will run terraform plan+apply."
          fi
          ls -la || true

      - name: Prepare optional ssh.auto.tfvars (from secret) if provided
        if: env.SSH_PUB_KEY != ''
        run: |
          # create ssh.auto.tfvars that Terraform can parse
          # Use a normal quoted string in tfvars (avoid <<'KEY' which caused parse errors)
          cat > ssh.auto.tfvars <<'EOF'
          ssh_public_key = "${{ secrets.SSH_PUB_KEY }}"
          EOF
          echo "Created ssh.auto.tfvars (length: $(wc -c < ssh.auto.tfvars) bytes)"

      - name: Terraform Apply (use plan.tfplan if present)
        id: tf_apply
        run: |
          set -euo pipefail
          if [ -f plan.tfplan ]; then
            echo "Applying existing plan..."
            terraform apply -input=false -auto-approve plan.tfplan
          else
            echo "No plan artifact found â€” running plan+apply..."
            terraform plan -input=false -no-color -out=plan.tfplan
            terraform apply -input=false -auto-approve plan.tfplan
          fi

      - name: Dump terraform outputs (json) and debug state
        run: |
          set -euo pipefail

          echo "PWD: $(pwd)"
          echo "Terraform version: $(terraform -version | head -n1 || true)"

          echo "---- capture pure JSON from terraform output -json ----"
          # Ensure we capture only the JSON part (strip any leading garbage that some runners/wrappers may emit)
          # We detect the first line that begins with '{' and print from there.
          terraform output -json 2>/dev/null | awk 'BEGIN{p=0} /^\s*{/ {p=1} p{print}' > tf_outputs.json || true

          echo "Exit status: $?"
          echo "---- tf_outputs.json (raw) ----"
          sed -n '1,200p' tf_outputs.json || true

          # Ensure jq is available
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

          echo "---- pretty print via jq ----"
          jq -C '.' tf_outputs.json || true

          echo "---- terraform state list ----"
          terraform state list || true

          echo "---- show specific outputs (human) ----"
          terraform output public_ips || true
          terraform output public_ip || true

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Extract public IPs from terraform outputs and set as job output
        id: set-hosts
        run: |
          set -euo pipefail
          TF_OUT="tf_outputs.json"
          # Ensure we are in TF_DIR (if defaults.run set)
          echo "PWD: $(pwd)"
          if [ ! -f "$TF_OUT" ]; then
            echo "tf_outputs.json not found at $(pwd)/$TF_OUT"
            echo "hosts=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Use python to safely parse JSON and extract hosts
          HOSTS=$(python3 - <<'PY'
          import json,sys
          fn = "tf_outputs.json"
          try:
              with open(fn, 'r', encoding='utf-8') as f:
                data = json.load(f)
          except Exception as e:
            # If parse fails, print nothing
            # (we avoid printing secret data; this is just for flow)
            sys.exit(0)

          # Try the common shapes
          hosts = []
          if "public_ips" in data and isinstance(data["public_ips"], dict):
              # expected terraform JSON shape: { "public_ips": { "value": [...] } }
              val = data["public_ips"].get("value")
              if isinstance(val, list):
                  hosts = [str(x) for x in val if x is not None]
          elif "public_ip" in data and isinstance(data["public_ip"], dict):
              val = data["public_ip"].get("value")
              if val:
                  hosts = [str(val)]
          else:
              # Fallback: try to find any values that look like IPv4 addresses
              import re
              def find_ips(obj):
                  ips = []
                  if isinstance(obj, dict):
                     for v in obj.values():
                         ips += find_ips(v)
                  elif isinstance(obj, list):
                      for v in obj:
                          ips += find_ips(v)
                  elif isinstance(obj, str):
                      if re.match(r'^([0-9]{1,3}\.){3}[0-9]{1,3}$', obj):
                          ips.append(obj)
                  return ips
              hosts = find_ips(data)

          # join into comma-separated string
          if hosts:
              print(",".join(hosts))
          # else print nothing (empty)
          PY
          )

          # Trim and fallback
          HOSTS=$(echo "${HOSTS}" | tr -d '\r' || true)
          if [ -n "${HOSTS}" ]; then
            echo "Found hosts: ${HOSTS}"
            echo "hosts=${HOSTS}" >> $GITHUB_OUTPUT
          else
            echo "No hosts found in tf_outputs.json"
            echo "hosts=" >> $GITHUB_OUTPUT
          fi

  deploy:
    name: Deploy Java (Ansible)
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: ${{ needs.terraform-apply.result == 'success' && github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    defaults:
      run:
        working-directory: .
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies (ansible & jq)
        run: |
          python -m pip install --upgrade pip
          pip install "ansible>=7.0"
          sudo apt-get update
          sudo apt-get install -y jq sshpass || true

      - name: Prepare SSH private key
        env:
          SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY || '' }}
        run: |
          if [ -z "${SSH_KEY}" ]; then
            echo "SSH_PRIVATE_KEY secret is empty. Exiting."
            exit 1
          fi
          printf '%s\n' "$SSH_KEY" > ./id_rsa
          chmod 600 ./id_rsa

      - name: Determine hosts (prefer secret, else use terraform output)
        id: compute-hosts
        run: |
          if [ -n "${{ secrets.HOSTS || '' }}" ]; then
            echo "hosts=${{ secrets.HOSTS }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ needs.terraform-apply.outputs.hosts || '' }}" ]; then
            echo "hosts=${{ needs.terraform-apply.outputs.hosts }}" >> $GITHUB_OUTPUT
          else
            echo "hosts=" >> $GITHUB_OUTPUT
          fi

      - name: Build inventory from computed hosts
        run: |
          mkdir -p inventory
          echo "[java_servers]" > inventory/hosts.ini
          HOSTS="${{ steps.compute-hosts.outputs.hosts }}"
          if [ -n "$HOSTS" ]; then
            IFS=',' read -ra ADDR <<< "$HOSTS"
            for h in "${ADDR[@]}"; do
              USER="${{ secrets.SSH_USER || 'ec2-user' }}"
              echo "${h} ansible_user=${USER} ansible_ssh_private_key_file=./id_rsa ansible_host=${h}" >> inventory/hosts.ini
            done
            echo "Inventory:"
            cat inventory/hosts.ini
          else
            echo "No hosts found. Ensure either secrets.HOSTS or terraform outputs.public_ips exist."
            exit 1
          fi

      - name: Add hosts to known_hosts (ssh-keyscan)
        run: |
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOSTS="${{ steps.compute-hosts.outputs.hosts }}"
          IFS=',' read -ra ADDR <<< "$HOSTS"
          for h in "${ADDR[@]}"; do
            ssh-keygen -F "$h" || ssh-keyscan -H "$h" >> ~/.ssh/known_hosts || true
          done
          sed -n '1,20p' ~/.ssh/known_hosts || true

      - name: Run Ansible playbook (install Java + deploy Spring jar if SPRING_BOOT_JAR_URL provided)
        env:
          ANSIBLE_HOST_KEY_CHECKING: "False"
          SPRING_BOOT_JAR_URL: ${{ secrets.SPRING_BOOT_JAR_URL || '' }}
        run: |
          ansible-playbook -i inventory/hosts.ini ansible/playbook.yml --private-key ./id_rsa -u "${{ secrets.SSH_USER || 'ec2-user' }}"

      - name: Cleanup private key (always)
        if: always()
        run: |
          shred -u ./id_rsa || rm -f ./id_rsa || true
