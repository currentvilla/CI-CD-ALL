#PR提出用
name: CI (Terraform plan/apply) and Deploy Java

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

permissions:
  contents: read

env:
  TF_DIR: tf

jobs:
  terraform-plan:
    name: Terraform - Plan
    runs-on: ubuntu-latest
    env:
      SSH_PUB_KEY: ${{ secrets.SSH_PUB_KEY || '' }}
    defaults:
      run:
        working-directory: ${{ env.TF_DIR }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-1

      - name: Terraform Init
        run: terraform init -input=false

      - name: Check terraform fmt
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: terraform validate

      - name: Prepare optional ssh.auto.tfvars (from secret) if provided
        if: env.SSH_PUB_KEY != ''
        run: |
          rm -f ssh.auto.tfvars
          cat > ssh.auto.tfvars <<-'EOF'
          ssh_public_key = "${{ secrets.SSH_PUB_KEY }}"
          EOF
          echo "Created ssh.auto.tfvars (length: $(wc -c < ssh.auto.tfvars 2>/dev/null || echo 0) bytes)"

      - name: Terraform Plan (create plan.tfplan)
        id: plan
        run: |
          set -euo pipefail
          terraform plan -input=false -no-color -out=plan.tfplan || true
          if [ -f plan.tfplan ]; then
            terraform show -no-color plan.tfplan > plan.txt || true
            head -n 200 plan.txt > plan_summary.txt || true
          else
            echo "No plan.tfplan produced (plan may have failed)." > plan_summary.txt
          fi

      - name: Debug before upload - show TF dir
        run: |
          echo "Workspace: $GITHUB_WORKSPACE"
          echo "TF_DIR: $TF_DIR"
          ls -la "${TF_DIR}" || true
          stat -c '%n %s' "${TF_DIR}/plan.tfplan" || true

      - name: Upload plan artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: |
            ${{ env.TF_DIR }}/plan.tfplan
            ${{ env.TF_DIR }}/plan_summary.txt

  terraform-apply:
    name: Terraform - Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    env:
      SSH_PUB_KEY: ${{ secrets.SSH_PUB_KEY || '' }}
    defaults:
      run:
        working-directory: ${{ env.TF_DIR }}
    outputs:
      hosts: ${{ steps.set-hosts.outputs.hosts || '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-1

      - name: Terraform Init
        run: terraform init -input=false

      - name: Download plan artifact (if exists)
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: ${{ env.TF_DIR }}

      - name: Prepare plan file (use downloaded artifact if present)
        id: prepare-plan
        run: |
          set -euo pipefail
          if [ -f plan.tfplan ]; then
            echo "plan.tfplan already present in TF_DIR"
          elif [ -f terraform-plan/plan.tfplan ]; then
            mv terraform-plan/plan.tfplan ./plan.tfplan
          elif [ -f ../terraform-plan/plan.tfplan ]; then
            mv ../terraform-plan/plan.tfplan ./plan.tfplan
          else
            echo "No plan.tfplan found from artifact. Will run terraform plan+apply."
          fi
          ls -la || true

      - name: Prepare optional ssh.auto.tfvars (from secret) if provided
        if: env.SSH_PUB_KEY != ''
        run: |
          rm -f ssh.auto.tfvars
          cat > ssh.auto.tfvars <<-'EOF'
          ssh_public_key = "${{ secrets.SSH_PUB_KEY }}"
          EOF
          echo "Created ssh.auto.tfvars (length: $(wc -c < ssh.auto.tfvars 2>/dev/null || echo 0) bytes)"

      - name: Terraform Apply (use plan.tfplan if present)
        id: tf_apply
        run: |
          set -euo pipefail
          if [ -f plan.tfplan ]; then
            echo "Applying existing plan..."
            terraform apply -input=false -auto-approve plan.tfplan
          else
            echo "No plan artifact found — running plan+apply..."
            terraform plan -input=false -no-color -out=plan.tfplan
            terraform apply -input=false -auto-approve plan.tfplan
          fi

      - name: Dump terraform outputs (json) and save
        run: |
          set -euo pipefail
          terraform output -json 2>/dev/null | awk 'BEGIN{p=0} /^\s*{/ {p=1} p{print}' > tf_outputs.json || true
          echo "PWD: $(pwd)"
          echo "ls -la:"
          ls -la || true
          echo "tf_outputs.json head:"
          sed -n '1,200p' tf_outputs.json || true

      - name: Upload tf_outputs.json artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tf-outputs
          path: ${{ env.TF_DIR }}/tf_outputs.json

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Extract public IPs from terraform outputs and set as job output
        id: set-hosts
        run: |
          set -euo pipefail
          HOSTS=""
          if [ -f tf_outputs.json ]; then
            JSON_FILE="tf_outputs.json"
          elif [ -f $TF_DIR/tf_outputs.json ]; then
            JSON_FILE="$TF_DIR/tf_outputs.json"
          else
            terraform output -json 2>/dev/null | awk 'BEGIN{p=0} /^\s*{/ {p=1} p{print}' > tf_outputs.json || true
            JSON_FILE="tf_outputs.json"
          fi
          
          awk 'BEGIN{p=0} /^\s*{/ {p=1} p{print}' "$JSON_FILE" > /tmp/tf_outputs_clean.json || true
          CLEAN="/tmp/tf_outputs_clean.json"

          if jq -e '.public_ips.value' "$CLEAN" >/dev/null 2>&1; then
            HOSTS=$(jq -r '.public_ips.value | join(",")' "$CLEAN")
          elif jq -e '.public_ip.value' "$CLEAN" >/dev/null 2>&1; then
            HOSTS=$(jq -r '.public_ip.value' "$CLEAN")
          else
            HOSTS=$(jq -r '...|strings' "$CLEAN" 2>/dev/null | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | paste -sd "," - || true)
          fi
          echo "Determined hosts: ${HOSTS}"
          echo "hosts=${HOSTS}" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy Java (Ansible)
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: ${{ needs.terraform-apply.result == 'success' && github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    env:
      TF_DIR: tf
    defaults:
      run:
        working-directory: .
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies (ansible & jq)
        run: |
          python -m pip install --upgrade pip
          pip install "ansible>=7.0"
          sudo apt-get update
          sudo apt-get install -y jq sshpass || true

      - name: Prepare SSH private key
        env:
          SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY || '' }}
        run: |
          if [ -z "${SSH_KEY}" ]; then
            echo "SSH_PRIVATE_KEY secret is empty. Exiting."
            exit 1
          fi
          printf '%s\n' "$SSH_KEY" > ./id_rsa
          chmod 600 ./id_rsa

      - name: Download tf_outputs.json artifact (if present)
        uses: actions/download-artifact@v4
        with:
          name: tf-outputs
          path: .

      - name: show downloaded artifacts and tf_outputs.json
        run: |
          echo "Workspace: $GITHUB_WORKSPACE"
          echo "TF_DIR: $TF_DIR"
          echo "ls -la (root):"
          ls -la || true
          echo "ls -la (TF_DIR):"
          ls -la "$TF_DIR" || true
          if [ -f tf_outputs.json ]; then
            echo "found tf_outputs.json in root"
            sed -n '1,200p' tf_outputs.json
          fi
          if [ -f "$TF_DIR/tf_outputs.json" ]; then
            echo "found tf_outputs.json in TF_DIR"
            sed -n '1,200p' "$TF_DIR/tf_outputs.json"
          fi

      - name: Determine hosts (prefer secret, else use terraform artifact)
        id: compute-hosts
        run: |
          set -euo pipefail
          if [ -n "${{ secrets.HOSTS || '' }}" ]; then
            echo "hosts=${{ secrets.HOSTS }}" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ -n "${{ needs.terraform-apply.outputs.hosts || '' }}" ]; then
            echo "hosts=${{ needs.terraform-apply.outputs.hosts }}" >> $GITHUB_OUTPUT
            exit 0
          fi

          HOSTS=""
          if [ -f tf_outputs.json ]; then
            HOSTS=$(jq -r '.public_ips.value | join(",")' tf_outputs.json 2>/dev/null || true)
          elif [ -f "$TF_DIR/tf_outputs.json" ]; then
            HOSTS=$(jq -r '.public_ips.value | join(",")' "$TF_DIR/tf_outputs.json" 2>/dev/null || true)
          fi

          echo "Determined hosts: ${HOSTS}"
          echo "hosts=${HOSTS}" >> $GITHUB_OUTPUT

      - name: Build inventory from computed hosts
        run: |
          set -euo pipefail

          # 1) まず compute-hosts の出力（ステップ出力）を優先して取得
          RAW_HOSTS="${{ steps.compute-hosts.outputs.hosts || '' }}"

          # 2) 次に secrets.HOSTS があれば上書き（管理者が明示的に上書きする場合）
          if [ -n "${{ secrets.HOSTS || '' }}" ]; then
            RAW_HOSTS="${{ secrets.HOSTS }}"
          fi

          # 3) 次に needs.terraform-apply.outputs.hosts を試す（古いフロー互換）
          if [ -z "${RAW_HOSTS}" ] && [ -n "${{ needs.terraform-apply.outputs.hosts || '' }}" ]; then
            RAW_HOSTS="${{ needs.terraform-apply.outputs.hosts }}"
          fi

          # 4) 最後に artifact/tf_outputs.json から抽出（fallback）
          if [ -z "${RAW_HOSTS}" ]; then
            if [ -f tf_outputs.json ]; then
              RAW_HOSTS=$(jq -r '.public_ips.value | join(",")' tf_outputs.json 2>/dev/null || true)
            elif [ -f "$TF_DIR/tf_outputs.json" ]; then
              RAW_HOSTS=$(jq -r '.public_ips.value | join(",")' "$TF_DIR/tf_outputs.json" 2>/dev/null || true)
            fi
          fi

          echo "DEBUG: raw hosts value='${RAW_HOSTS:-}'"

          # 5) 正規化（空白・改行をカンマ化、重複カンマ排除、先頭末尾カンマ削除）
          NORM=$(printf "%s" "${RAW_HOSTS:-}" | tr -s ' \n' ',' | sed 's/,,*/,/g' | sed 's/^,//;s/,$//')

          if [ -z "${NORM}" ]; then
            echo "No hosts found. Ensure compute-hosts output, secrets.HOSTS, needs.terraform-apply.outputs.hosts, or tf_outputs.json exist."
            exit 1
          fi

          mkdir -p inventory
          echo "[java_servers]" > inventory/hosts.ini

          IFS=',' read -ra ADDR <<< "$NORM"
          for h in "${ADDR[@]}"; do
            if [ -n "$h" ]; then
              USER="${{ secrets.SSH_USER || 'ec2-user' }}"
          echo "${h} ansible_user=${USER} ansible_ssh_private_key_file=./id_rsa ansible_host=${h}" >> inventory/hosts.ini
            fi
          done

          echo "Inventory:"
          cat inventory/hosts.ini

          echo "DEBUG: raw hosts value='${RAW_HOSTS:-}'"

          if [ -z "${NORM}" ]; then
            echo "No hosts found. Ensure either secrets.HOSTS, needs.terraform-apply.outputs.hosts, or tf_outputs.json exist."
            exit 1
          fi

          mkdir -p inventory
          echo "[java_servers]" > inventory/hosts.ini

          IFS=',' read -ra ADDR <<< "$NORM"
          for h in "${ADDR[@]}"; do
            if [ -n "$h" ]; then
              USER="${{ secrets.SSH_USER || 'ec2-user' }}"
              echo "${h} ansible_user=${USER} ansible_ssh_private_key_file=./id_rsa ansible_host=${h}" >> inventory/hosts.ini
            fi
          done

          echo "Inventory:"
          cat inventory/hosts.ini

      - name: Add hosts to known_hosts (ssh-keyscan)
        run: |
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOSTS="${{ steps.compute-hosts.outputs.hosts }}"
          IFS=',' read -ra ADDR <<< "$HOSTS"
          for h in "${ADDR[@]}"; do
            ssh-keygen -F "$h" || ssh-keyscan -H "$h" >> ~/.ssh/known_hosts || true
          done
          sed -n '1,20p' ~/.ssh/known_hosts || true

      - name: Run Ansible playbook (install Java + deploy Spring jar if SPRING_BOOT_JAR_URL provided)
        env:
          ANSIBLE_HOST_KEY_CHECKING: "False"
          SPRING_BOOT_JAR_URL: ${{ secrets.SPRING_BOOT_JAR_URL || '' }}
        run: |
          ansible-playbook -i inventory/hosts.ini ansible/playbook.yml --private-key ./id_rsa -u "${{ secrets.SSH_USER || 'ec2-user' }}"

      - name: Cleanup private key (always)
        if: always()
        run: |
          shred -u ./id_rsa || rm -f ./id_rsa || true