name: CI (Terraform plan/apply) and Deploy Java

on:
  push:
    branches:
      - main
    paths:
      - 'tf/**'
  workflow_dispatch:

permissions:
  contents: read

env:
  TF_DIR: tf    # Terraform の作業ディレクトリ（必要なら変更）

jobs:
  # 1) Terraform Plan
  terraform-plan:
    name: Terraform - Plan
    runs-on: ubuntu-latest
    env:
      SSH_PUB_KEY: ${{ secrets.SSH_PUB_KEY || '' }}
    defaults:
      run:
        working-directory: ${{ env.TF_DIR }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-1

      - name: Terraform Init
        run: terraform init -input=false

      - name: Check terraform fmt
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: terraform validate

      - name: Prepare optional ssh.auto.tfvars (from secret) if provided
        if: env.SSH_PUB_KEY != ''
        run: |
          # create a tfvars file that defines ssh_public_key variable
          cat > ssh.auto.tfvars <<'TFVARS'
          ssh_public_key = <<'KEY'
          ${{ secrets.SSH_PUB_KEY }}
          KEY
          TFVARS
          echo "Created ssh.auto.tfvars (length: $(wc -c < ssh.auto.tfvars) bytes)"

      - name: Terraform Plan (create plan.tfplan)
        id: plan
        run: |
          set -euo pipefail
          # run terraform plan, output plan.tfplan in current directory
          terraform plan -input=false -no-color -out=plan.tfplan || true

          if [ -f plan.tfplan ]; then
            terraform show -no-color plan.tfplan > plan.txt || true
            head -n 200 plan.txt > plan_summary.txt || true
          else
            echo "No plan.tfplan produced (plan may have failed)."
            echo "" > plan_summary.txt
          fi

      - name: "Debug: list TF dir files"
        run: |
          ls -la

      - name: Upload plan artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: |
            plan.tfplan
            plan_summary.txt

  # 2) Terraform Apply (only on push to main)
  terraform-apply:
    name: Terraform - Apply
    runs-on: ubuntu-latest
    env:
      SSH_PUB_KEY: ${{ secrets.SSH_PUB_KEY || '' }}
    needs: terraform-plan
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    defaults:
      run:
        working-directory: ${{ env.TF_DIR }}
    outputs:
      hosts: ${{ steps.set-hosts.outputs.hosts }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-1

      - name: Terraform Init
        run: terraform init -input=false

      - name: Download plan artifact (if exists)
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: ${{ env.TF_DIR }}

      - name: Prepare plan file (use downloaded artifact if present)
        id: prepare-plan
        run: |
          set -euo pipefail
          # if download-artifact created terraform-plan/plan.tfplan put it in working dir
          if [ -f plan.tfplan ]; then
            echo "plan.tfplan already present in TF_DIR"
          elif [ -f terraform-plan/plan.tfplan ]; then
            mv terraform-plan/plan.tfplan ./plan.tfplan
          elif [ -f ../terraform-plan/plan.tfplan ]; then
            mv ../terraform-plan/plan.tfplan ./plan.tfplan
          else
            echo "No plan.tfplan found from artifact. Will run terraform plan+apply."
          fi
          ls -la || true

      - name: Prepare optional ssh.auto.tfvars (from secret) if provided
        if: env.SSH_PUB_KEY != ''
        run: |
          # Create ssh.auto.tfvars in TF_DIR (ensure idempotent)
          cat > ssh.auto.tfvars <<'TFVARS'
          ssh_public_key = <<'KEY'
          ${{ secrets.SSH_PUB_KEY }}
          KEY
          TFVARS
          echo "Created ssh.auto.tfvars (length: $(wc -c < ssh.auto.tfvars) bytes)"

      - name: Terraform Apply (use plan.tfplan if present)
        id: tf_apply
        run: |
          set -euo pipefail
          if [ -f plan.tfplan ]; then
            echo "Applying existing plan..."
            terraform apply -input=false -auto-approve plan.tfplan
          else
            echo "No plan artifact found — running plan+apply..."
            terraform plan -input=false -no-color -out=plan.tfplan
            terraform apply -input=false -auto-approve plan.tfplan
          fi

      - name: Dump terraform outputs (json)
        run: terraform output -json > tf_outputs.json

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Extract public IPs from terraform outputs and set as job output
        id: set-hosts
        run: |
          HOSTS=""
          if jq -e '.public_ips' tf_outputs.json >/dev/null 2>&1; then
            HOSTS=$(jq -r '.public_ips | join(",")' tf_outputs.json)
          elif jq -e '.public_ip' tf_outputs.json >/dev/null 2>&1; then
            VAL=$(jq -r '.public_ip.value // .public_ip' tf_outputs.json)
            HOSTS="$VAL"
          else
            HOSTS=$(jq -r 'to_entries[] | .value.value? // empty | tostring' tf_outputs.json | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | paste -sd "," - || true)
          fi
          echo "hosts=$HOSTS" >> $GITHUB_OUTPUT

  # 3) Deploy: run Ansible after apply completes successfully
  deploy:
    name: Deploy Java (Ansible)
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: ${{ needs.terraform-apply.result == 'success' && github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    defaults:
      run:
        working-directory: .
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies (ansible & jq)
        run: |
          python -m pip install --upgrade pip
          pip install "ansible>=7.0"
          sudo apt-get update
          sudo apt-get install -y jq sshpass || true

      - name: Prepare SSH private key
        env:
          SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY || '' }}
        run: |
          if [ -z "${SSH_KEY}" ]; then
            echo "SSH_PRIVATE_KEY secret is empty. Exiting."
            exit 1
          fi
          printf '%s\n' "$SSH_KEY" > ./id_rsa
          chmod 600 ./id_rsa

      - name: Determine hosts (prefer secret, else use terraform output)
        id: compute-hosts
        run: |
          if [ -n "${{ secrets.HOSTS || '' }}" ]; then
            echo "hosts=${{ secrets.HOSTS }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ needs.terraform-apply.outputs.hosts || '' }}" ]; then
            echo "hosts=${{ needs.terraform-apply.outputs.hosts }}" >> $GITHUB_OUTPUT
          else
            echo "hosts=" >> $GITHUB_OUTPUT
          fi

      - name: Build inventory from computed hosts
        run: |
          mkdir -p inventory
          echo "[java_servers]" > inventory/hosts.ini
          HOSTS="${{ steps.compute-hosts.outputs.hosts }}"
          if [ -n "$HOSTS" ]; then
            IFS=',' read -ra ADDR <<< "$HOSTS"
            for h in "${ADDR[@]}"; do
              USER="${{ secrets.SSH_USER || 'ec2-user' }}"
              echo "${h} ansible_user=${USER} ansible_ssh_private_key_file=./id_rsa ansible_host=${h}" >> inventory/hosts.ini
            done
            echo "Inventory:"
            cat inventory/hosts.ini
          else
            echo "No hosts found. Ensure either secrets.HOSTS or terraform outputs.public_ips exist."
            exit 1
          fi

      - name: Add hosts to known_hosts (ssh-keyscan)
        run: |
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOSTS="${{ steps.compute-hosts.outputs.hosts }}"
          IFS=',' read -ra ADDR <<< "$HOSTS"
          for h in "${ADDR[@]}"; do
            ssh-keygen -F "$h" || ssh-keyscan -H "$h" >> ~/.ssh/known_hosts || true
          done
          sed -n '1,20p' ~/.ssh/known_hosts || true

      - name: Run Ansible playbook (install Java + deploy Spring jar if SPRING_BOOT_JAR_URL provided)
        env:
          ANSIBLE_HOST_KEY_CHECKING: "False"
          SPRING_BOOT_JAR_URL: ${{ secrets.SPRING_BOOT_JAR_URL || '' }}
        run: |
          ansible-playbook -i inventory/hosts.ini ansible/playbook.yml --private-key ./id_rsa -u "${{ secrets.SSH_USER || 'ec2-user' }}"

      - name: Cleanup private key (always)
        if: always()
        run: |
          shred -u ./id_rsa || rm -f ./id_rsa || true
